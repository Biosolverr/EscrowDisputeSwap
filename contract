// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract DeferredValueSwap is ReentrancyGuard, Ownable, ERC721 {
    enum State {
        Inactive,
        Active,
        FinalNFT,
        FinalStable,
        Cancelled,
        Disputed
    }

    enum DisputeOutcome {
        None,
        RefundSender,   // all escrow back to sender
        PayRecipient,   // all escrow to recipient (minus fee)
        Split           // split escrow between sender & recipient (recipient part minus fee)
    }

    enum NftPayoutMode {
        Hold,           // keep escrow in contract (not recommended)
        RefundSender,   // finalize NFT == acknowledgement only
        PayRecipient    // finalize NFT == completed delivery
    }

    struct Deal {
        address sender;
        address recipient;
        State state;

        uint256 initialValue;
        uint256 currentValue;
        uint256 deposit; // escrowed ETH remaining

        uint256 createdAt;
        uint256 activatedAt;
        uint256 finalizedAt;

        uint256 activationDeadline;
        uint256 finalizationDeadline;

        string offchainRef;
        string nftMetadata;

        // dispute
        bool disputeOpen;
        address claimBy;
        string claimReason;
        uint256 claimOpenedAt;
        uint256 claimDeadline;

        address challengeBy;
        string challengeReason;

        uint256 resolutionMode; // 1 owner manual, 2 ai judge, etc.
        string resolutionNote;
    }

    uint256 public nextDealId = 1;
    uint256 private _nextTokenId = 1;

    mapping(uint256 => Deal) public deals;

    // NFT data
    mapping(uint256 => string) private _tokenURIs;
    mapping(uint256 => uint256) public nftToDeal; // tokenId => dealId

    // Config
    uint256 public disputePeriodSec;
    uint256 public baseActivationFee;
    uint256 public globalValueMultiplierBps = 10_000;
    uint256 public transformFeeBps = 100; // 1%
    uint256 public protocolFeesCollected;

    // Security / limits
    mapping(address => bool) public blacklisted;
    uint256 public maxDealValue; // 0 = no limit
    uint256 public minDelaySec;  // 0 = no delay
    mapping(address => uint256) public lastActionAt;

    uint256 public defaultActivationPeriodSec;
    uint256 public defaultFinalizationPeriodSec;

    // Reputation
    mapping(address => uint256) public xp;
    mapping(address => uint256) public wins;

    // XP tiers -> fee discounts
    uint256 public xpTier1 = 10;
    uint256 public xpTier2 = 50;
    uint256 public xpTier3 = 100;
    uint256 public discountTier1Bps = 1000; // 10%
    uint256 public discountTier2Bps = 2500; // 25%
    uint256 public discountTier3Bps = 5000; // 50%

    // NFT payout mode
    NftPayoutMode public nftPayoutMode = NftPayoutMode.PayRecipient;

    // AI Judge (optional resolver)
    address public aiJudge;

    event DealCreated(uint256 indexed dealId, address indexed sender, address indexed recipient, uint256 value, string offchainRef);
    event DealActivated(uint256 indexed dealId);
    event DealCancelled(uint256 indexed dealId);

    event NFTMinted(uint256 indexed tokenId, uint256 indexed dealId, address indexed to);
    event DealFinalizedToNFT(
        uint256 indexed dealId,
        uint256 tokenId,
        string metadata,
        NftPayoutMode payoutMode,
        uint256 paidToRecipient,
        uint256 refundedToSender,
        uint256 fee
    );
    event DealFinalizedToStable(uint256 indexed dealId, uint256 paidNet, uint256 fee, uint256 refundedToSender);

    event DisputeOpened(uint256 indexed dealId, address indexed by, string reason);
    event DisputeChallenged(uint256 indexed dealId, address indexed by, string reason);
    event DisputeResolved(
        uint256 indexed dealId,
        uint256 mode,
        string note,
        DisputeOutcome outcome,
        uint256 recipientBps,
        uint256 paidToRecipient,
        uint256 refundedToSender,
        uint256 fee
    );

    event NftPayoutModeSet(NftPayoutMode mode);
    event AiJudgeSet(address aiJudge);

    // Errors
    error OnlySender();
    error OnlyRecipient();
    error OnlyParticipant();
    error OnlyResolver();
    error UnknownDeal();
    error Blacklisted();
    error TooFrequent();
    error BadState();
    error DeadlinePassed();
    error DeadlineNotPassed();
    error ValueInvalid();
    error ValueTooHigh();
    error BadMsgValue();
    error NothingToPayout();
    error TransferFailed();
    error BadParams();
    error FeeTooHigh();
    error MultiplierTooHigh();
    error InvalidBps();

    constructor() Ownable(msg.sender) ERC721("DeferredValueSwapNFT", "DVS") {}

    modifier notBlacklisted(address a) {
        if (blacklisted[a]) revert Blacklisted();
        _;
    }

    // ---------- internal helpers ----------

    function _respectDelay(address a) internal {
        if (minDelaySec == 0) return;
        uint256 last = lastActionAt[a];
        if (last != 0 && block.timestamp < last + minDelaySec) revert TooFrequent();
        lastActionAt[a] = block.timestamp;
    }

    function _calcValue(uint256 initial) internal view returns (uint256) {
        if (globalValueMultiplierBps == 0) return initial;
        return (initial * globalValueMultiplierBps) / 10_000;
    }

    function _dealExists(uint256 dealId) internal view returns (bool) {
        return deals[dealId].sender != address(0);
    }

    function _sendETH(address to, uint256 amount) internal {
        if (amount == 0) return;
        (bool ok,) = to.call{value: amount}("");
        if (!ok) revert TransferFailed();
    }

    function _feeDiscountBps(address user) internal view returns (uint256) {
        uint256 userXp = xp[user];
        if (userXp >= xpTier3) return discountTier3Bps;
        if (userXp >= xpTier2) return discountTier2Bps;
        if (userXp >= xpTier1) return discountTier1Bps;
        return 0;
    }

    function _calcFee(uint256 gross, address user) internal view returns (uint256) {
        uint256 baseFee = (gross * transformFeeBps) / 10_000;
        uint256 discount = _feeDiscountBps(user);
        if (discount == 0) return baseFee;
        return baseFee - (baseFee * discount) / 10_000;
    }

    function _payoutRecipientMinusFee(Deal storage d, uint256 gross) internal returns (uint256 net, uint256 fee) {
        if (gross == 0) return (0, 0);
        fee = _calcFee(gross, d.recipient);
        net = gross - fee;

        protocolFeesCollected += fee;
        _sendETH(d.recipient, net);
    }

    // ---------- core flow ----------

    function createDeal(address recipient, uint256 value, string calldata offchainRef)
        external
        payable
        notBlacklisted(msg.sender)
        notBlacklisted(recipient)
        nonReentrant
        returns (uint256 dealId)
    {
        _respectDelay(msg.sender);
        if (recipient == address(0)) revert BadParams();
        if (value == 0) revert ValueInvalid();
        if (maxDealValue != 0 && value > maxDealValue) revert ValueTooHigh();

        uint256 expected = value + baseActivationFee;
        if (msg.value != expected) revert BadMsgValue();

        if (baseActivationFee > 0) protocolFeesCollected += baseActivationFee;

        dealId = nextDealId++;
        Deal storage d = deals[dealId];

        d.sender = msg.sender;
        d.recipient = recipient;
        d.state = State.Inactive;

        d.initialValue = value;
        d.currentValue = _calcValue(value);
        d.deposit = value;

        d.createdAt = block.timestamp;
        d.offchainRef = offchainRef;

        if (defaultActivationPeriodSec > 0) {
            d.activationDeadline = block.timestamp + defaultActivationPeriodSec;
        }

        xp[msg.sender] += 1;
        emit DealCreated(dealId, msg.sender, recipient, value, offchainRef);
    }

    function activateDeal(uint256 dealId) external notBlacklisted(msg.sender) nonReentrant {
        _respectDelay(msg.sender);
        if (!_dealExists(dealId)) revert UnknownDeal();

        Deal storage d = deals[dealId];
        if (msg.sender != d.sender && msg.sender != d.recipient) revert OnlyParticipant();
        if (d.state != State.Inactive) revert BadState();
        if (d.activationDeadline != 0 && block.timestamp > d.activationDeadline) revert DeadlinePassed();

        d.state = State.Active;
        d.activatedAt = block.timestamp;

        if (defaultFinalizationPeriodSec > 0) {
            d.finalizationDeadline = block.timestamp + defaultFinalizationPeriodSec;
        }

        xp[d.sender] += 1;
        xp[d.recipient] += 1;

        emit DealActivated(dealId);
    }

    function cancelInactive(uint256 dealId) external notBlacklisted(msg.sender) nonReentrant {
        _respectDelay(msg.sender);
        if (!_dealExists(dealId)) revert UnknownDeal();

        Deal storage d = deals[dealId];
        if (msg.sender != d.sender) revert OnlySender();
        if (d.state != State.Inactive) revert BadState();

        uint256 amount = d.deposit;
        d.deposit = 0;
        d.state = State.Cancelled;
        d.finalizedAt = block.timestamp;

        _sendETH(d.sender, amount);
        emit DealCancelled(dealId);
    }

    function expireDeal(uint256 dealId) external notBlacklisted(msg.sender) nonReentrant {
        _respectDelay(msg.sender);
        if (!_dealExists(dealId)) revert UnknownDeal();

        Deal storage d = deals[dealId];
        if (msg.sender != d.sender && msg.sender != d.recipient) revert OnlyParticipant();

        if (d.state == State.Inactive) {
            if (d.activationDeadline == 0 || block.timestamp <= d.activationDeadline) revert DeadlineNotPassed();
        } else if (d.state == State.Active) {
            if (d.finalizationDeadline == 0 || block.timestamp <= d.finalizationDeadline) revert DeadlineNotPassed();
        } else {
            revert BadState();
        }

        uint256 amount = d.deposit;
        d.deposit = 0;
        d.state = State.Cancelled;
        d.finalizedAt = block.timestamp;

        _sendETH(d.sender, amount);
        emit DealCancelled(dealId);
    }

    // ---------- finalization ----------

    function finalizeToNFT(uint256 dealId, string calldata metadata)
        external
        notBlacklisted(msg.sender)
        nonReentrant
    {
        _respectDelay(msg.sender);
        if (!_dealExists(dealId)) revert UnknownDeal();

        Deal storage d = deals[dealId];
        if (msg.sender != d.recipient) revert OnlyRecipient();
        if (d.state != State.Active) revert BadState();
        if (d.finalizationDeadline != 0 && block.timestamp > d.finalizationDeadline) revert DeadlinePassed();

        // finalize state
        d.state = State.FinalNFT;
        d.nftMetadata = metadata;
        d.finalizedAt = block.timestamp;

        // mint NFT
        uint256 tokenId = _nextTokenId++;
        _tokenURIs[tokenId] = metadata;
        nftToDeal[tokenId] = dealId;
        _safeMint(d.recipient, tokenId);
        emit NFTMinted(tokenId, dealId, d.recipient);

        // handle escrow according to mode (fixes "funds stuck" bug in contract #2)
        uint256 paidToRecipient;
        uint256 refundedToSender;
        uint256 fee;

        uint256 deposit = d.deposit;
        if (deposit > 0) {
            if (nftPayoutMode == NftPayoutMode.Hold) {
                // keep deposit as-is (escrow remains in contract)
            } else {
                d.deposit = 0;
                if (nftPayoutMode == NftPayoutMode.PayRecipient) {
                    (paidToRecipient, fee) = _payoutRecipientMinusFee(d, deposit);
                } else {
                    _sendETH(d.sender, deposit);
                    refundedToSender = deposit;
                }
            }
        }

        xp[d.recipient] += 5;
        wins[d.recipient] += 1;

        emit DealFinalizedToNFT(dealId, tokenId, metadata, nftPayoutMode, paidToRecipient, refundedToSender, fee);
    }

    function finalizeToStable(uint256 dealId)
        external
        notBlacklisted(msg.sender)
        nonReentrant
    {
        _respectDelay(msg.sender);
        if (!_dealExists(dealId)) revert UnknownDeal();

        Deal storage d = deals[dealId];
        if (msg.sender != d.recipient) revert OnlyRecipient();
        if (d.state != State.Active) revert BadState();
        if (d.finalizationDeadline != 0 && block.timestamp > d.finalizationDeadline) revert DeadlinePassed();

        uint256 deposit = d.deposit;
        if (deposit == 0) revert NothingToPayout();

        uint256 currentValue = d.currentValue;
        if (currentValue == 0) revert NothingToPayout();

        uint256 gross = currentValue > deposit ? deposit : currentValue;

        d.deposit = 0;
        d.state = State.FinalStable;
        d.finalizedAt = block.timestamp;

        (uint256 net, uint256 fee) = _payoutRecipientMinusFee(d, gross);

        // return leftover to sender (fixes "dust lock" bug in contract #2)
        uint256 refundedToSender = deposit - gross;
        if (refundedToSender > 0) _sendETH(d.sender, refundedToSender);

        xp[d.recipient] += 5;
        wins[d.recipient] += 1;

        emit DealFinalizedToStable(dealId, net, fee, refundedToSender);
    }

    // ---------- disputes ----------

    function openDispute(uint256 dealId, string calldata reason)
        external
        notBlacklisted(msg.sender)
        nonReentrant
    {
        _respectDelay(msg.sender);
        if (!_dealExists(dealId)) revert UnknownDeal();

        Deal storage d = deals[dealId];
        if (msg.sender != d.sender && msg.sender != d.recipient) revert OnlyParticipant();
        if (d.state != State.Active) revert BadState();
        if (d.disputeOpen) revert BadState();

        d.disputeOpen = true;
        d.claimBy = msg.sender;
        d.claimReason = reason;
        d.claimOpenedAt = block.timestamp;
        if (disputePeriodSec > 0) d.claimDeadline = block.timestamp + disputePeriodSec;
        d.state = State.Disputed;

        emit DisputeOpened(dealId, msg.sender, reason);
    }

    function challengeDispute(uint256 dealId, string calldata reason)
        external
        notBlacklisted(msg.sender)
        nonReentrant
    {
        _respectDelay(msg.sender);
        if (!_dealExists(dealId)) revert UnknownDeal();

        Deal storage d = deals[dealId];
        if (msg.sender != d.sender && msg.sender != d.recipient) revert OnlyParticipant();
        if (!d.disputeOpen) revert BadState();
        if (d.challengeBy != address(0)) revert BadState();

        d.challengeBy = msg.sender;
        d.challengeReason = reason;

        emit DisputeChallenged(dealId, msg.sender, reason);
    }

    function resolveDispute(
        uint256 dealId,
        uint256 mode,
        string calldata note,
        DisputeOutcome outcome,
        uint256 recipientBps
    )
        external
        nonReentrant
    {
        if (msg.sender != owner() && msg.sender != aiJudge) revert OnlyResolver();
        if (!_dealExists(dealId)) revert UnknownDeal();

        if (outcome == DisputeOutcome.None) revert BadParams();
        if (outcome == DisputeOutcome.Split) {
            if (recipientBps > 10_000) revert InvalidBps();
        } else {
            if (recipientBps != 0) revert InvalidBps();
        }

        Deal storage d = deals[dealId];
        if (d.state != State.Disputed) revert BadState();

        d.resolutionMode = mode;
        d.resolutionNote = note;

        uint256 deposit = d.deposit;
        d.deposit = 0;
        d.state = State.Cancelled;
        d.finalizedAt = block.timestamp;

        uint256 paidToRecipient;
        uint256 refundedToSender;
        uint256 fee;

        if (deposit > 0) {
            if (outcome == DisputeOutcome.RefundSender) {
                _sendETH(d.sender, deposit);
                refundedToSender = deposit;
            } else if (outcome == DisputeOutcome.PayRecipient) {
                (paidToRecipient, fee) = _payoutRecipientMinusFee(d, deposit);
            } else {
                uint256 grossToRecipient = (deposit * recipientBps) / 10_000;
                uint256 toSender = deposit - grossToRecipient;

                if (grossToRecipient > 0) {
                    (paidToRecipient, fee) = _payoutRecipientMinusFee(d, grossToRecipient);
                }
                if (toSender > 0) {
                    _sendETH(d.sender, toSender);
                    refundedToSender = toSender;
                }
            }
        }

        // xp for "winner-ish" in split (optional heuristic)
        if (outcome == DisputeOutcome.RefundSender) {
            xp[d.sender] += 3; wins[d.sender] += 1;
        } else if (outcome == DisputeOutcome.PayRecipient) {
            xp[d.recipient] += 3; wins[d.recipient] += 1;
        } else {
            if (recipientBps > 5000) { xp[d.recipient] += 3; wins[d.recipient] += 1; }
            else if (recipientBps < 5000) { xp[d.sender] += 3; wins[d.sender] += 1; }
        }

        emit DisputeResolved(dealId, mode, note, outcome, recipientBps, paidToRecipient, refundedToSender, fee);
    }

    // ---------- ERC721 metadata ----------

    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        _requireOwned(tokenId);
        return _tokenURIs[tokenId];
    }

    // ---------- admin ----------

    function setTimeouts(uint256 activationPeriod, uint256 finalizationPeriod, uint256 disputePeriod, uint256 minDelay)
        external
        onlyOwner
    {
        defaultActivationPeriodSec = activationPeriod;
        defaultFinalizationPeriodSec = finalizationPeriod;
        disputePeriodSec = disputePeriod;
        minDelaySec = minDelay;
    }

    function setFees(uint256 activationFee, uint256 _transformFeeBps, uint256 multiplierBps)
        external
        onlyOwner
    {
        // Safety bounds (tweak as desired)
        if (_transformFeeBps > 1_000) revert FeeTooHigh();         // max 10%
        if (multiplierBps > 20_000) revert MultiplierTooHigh();    // max 2x

        baseActivationFee = activationFee;
        transformFeeBps = _transformFeeBps;
        globalValueMultiplierBps = multiplierBps;
    }

    function setLimits(uint256 _maxDealValue) external onlyOwner {
        maxDealValue = _maxDealValue;
    }

    function setBlacklist(address a, bool flag) external onlyOwner {
        blacklisted[a] = flag;
    }

    function setNftPayoutMode(NftPayoutMode mode) external onlyOwner {
        nftPayoutMode = mode;
        emit NftPayoutModeSet(mode);
    }

    function setAiJudge(address _aiJudge) external onlyOwner {
        aiJudge = _aiJudge;
        emit AiJudgeSet(_aiJudge);
    }

    function setXpTiers(
        uint256 t1, uint256 t2, uint256 t3,
        uint256 d1, uint256 d2, uint256 d3
    ) external onlyOwner {
        if (d1 > 10_000 || d2 > 10_000 || d3 > 10_000) revert InvalidBps();
        xpTier1 = t1; xpTier2 = t2; xpTier3 = t3;
        discountTier1Bps = d1; discountTier2Bps = d2; discountTier3Bps = d3;
    }

    function withdrawProtocolFees(address to, uint256 amount) external onlyOwner nonReentrant {
        if (to == address(0)) revert BadParams();
        if (amount > protocolFeesCollected) amount = protocolFeesCollected;
        protocolFeesCollected -= amount;
        _sendETH(to, amount);
    }

    function getXpDiscount(address user) external view returns (uint256) {
        return _feeDiscountBps(user);
    }

    receive() external payable {}
}
